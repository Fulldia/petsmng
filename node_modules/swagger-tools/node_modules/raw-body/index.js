/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * @private
 */

var bytes = require('bytes')
<<<<<<< HEAD
var createError = require('http-errors')
var iconv = require('iconv-lite')
var unpipe = require('unpipe')
=======
var iconv = require('iconv-lite')
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538

/**
 * Module exports.
 * @public
 */

module.exports = getRawBody

/**
<<<<<<< HEAD
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /

/**
=======
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

<<<<<<< HEAD
function getDecoder (encoding) {
  if (!encoding) return null

  try {
    return iconv.getDecoder(encoding)
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e

    // the encoding was not found
    throw createError(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    })
=======
function getDecoder(encoding) {
  if (!encoding) return null

  try {
    return iconv.getCodec(encoding).decoder()
  } catch (e) {
    var err = makeError('specified encoding unsupported', 'encoding.unsupported')
    err.status = err.statusCode = 415
    err.encoding = encoding
    throw err
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

<<<<<<< HEAD
function getRawBody (stream, options, callback) {
=======
function getRawBody(stream, options, callback) {
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  var done = callback
  var opts = options || {}

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, done)
  }

<<<<<<< HEAD
  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
=======
  return new Promise(function executor(resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead(err, buf) {
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
      if (err) return reject(err)
      resolve(buf)
    })
  })
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

<<<<<<< HEAD
function halt (stream) {
=======
function halt(stream) {
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  // unpipe everything from the stream
  unpipe(stream)

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause()
  }
}

/**
<<<<<<< HEAD
=======
 * Determine if there are Node.js pipe-like data listeners.
 */

/* istanbul ignore next: implementation differs between versions */
function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data')

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true
    }
  }

  return false
}

/**
 * Make a serializable error object.
 *
 * To create serializable errors you must re-set message so
 * that it is enumerable and you must re configure the type
 * property so that is writable and enumerable.
 *
 * @param {string} message
 * @param {string} type
 * @param {object} props
 * @private
 */

function makeError(message, type, props) {
  var error = new Error()

  for (var prop in props) {
    error[prop] = props[prop]
  }

  error.message = message

  Object.defineProperty(error, 'type', {
    value: type,
    enumerable: true,
    writable: true,
    configurable: true
  })

  return error
}

/**
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

<<<<<<< HEAD
function readStream (stream, encoding, length, limit, callback) {
  var complete = false
  var sync = true

=======
function readStream(stream, encoding, length, limit, callback) {
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
<<<<<<< HEAD
    return done(createError(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }))
=======
    var err = makeError('request entity too large', 'entity.too.large', {
      expected: length,
      length: length,
      limit: limit,
      status: 413,
      statusCode: 413
    })

    return process.nextTick(function () {
      done(err)
    })
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState
  if (stream._decoder || (state && (state.encoding || state.decoder))) {
    // developer error
<<<<<<< HEAD
    return done(createError(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }))
=======
    var err = makeError('stream encoding should not be set', 'stream.encoding.set', {
      status: 500,
      statusCode: 500
    })

    return process.nextTick(function () {
      done(err)
    })
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }

  var received = 0
  var decoder

  try {
    decoder = getDecoder(encoding)
  } catch (err) {
<<<<<<< HEAD
    return done(err)
=======
    return process.nextTick(function () {
      done(err)
    })
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }

  var buffer = decoder
    ? ''
    : []

<<<<<<< HEAD
  // attach listeners
  stream.on('aborted', onAborted)
  stream.on('close', cleanup)
  stream.on('data', onData)
  stream.on('end', onEnd)
  stream.on('error', onEnd)

  // mark sync section complete
  sync = false

  function done () {
    var args = new Array(arguments.length)

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    // mark complete
    complete = true

    if (sync) {
      process.nextTick(invokeCallback)
    } else {
      invokeCallback()
    }

    function invokeCallback () {
      cleanup()

      if (args[0]) {
        // halt the stream on error
        halt(stream)
      }

      callback.apply(null, args)
    }
  }

  function onAborted () {
    if (complete) return

    done(createError(400, 'request aborted', {
=======
  stream.on('aborted', onAborted)
  stream.on('data', onData)
  stream.once('end', onEnd)
  stream.once('error', onEnd)
  stream.once('close', cleanup)

  function done(err) {
    cleanup()

    if (err) {
      // halt the stream on error
      halt(stream)
    }

    callback.apply(this, arguments)
  }

  function onAborted() {
    done(makeError('request aborted', 'request.aborted', {
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
<<<<<<< HEAD
      type: 'request.aborted'
    }))
  }

  function onData (chunk) {
    if (complete) return

    received += chunk.length

    if (limit !== null && received > limit) {
      done(createError(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }))
    } else if (decoder) {
      buffer += decoder.write(chunk)
    } else {
      buffer.push(chunk)
    }
  }

  function onEnd (err) {
    if (complete) return
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(createError(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
=======
      status: 400,
      statusCode: 400
    }))
  }

  function onData(chunk) {
    received += chunk.length
    decoder
      ? buffer += decoder.write(chunk)
      : buffer.push(chunk)

    if (limit !== null && received > limit) {
      done(makeError('request entity too large', 'entity.too.large', {
        limit: limit,
        received: received,
        status: 413,
        statusCode: 413
      }))
    }
  }

  function onEnd(err) {
    if (err) return done(err)

    if (length !== null && received !== length) {
      done(makeError('request size did not match content length', 'request.size.invalid', {
        expected: length,
        length: length,
        received: received,
        status: 400,
        statusCode: 400
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
      }))
    } else {
      var string = decoder
        ? buffer + (decoder.end() || '')
        : Buffer.concat(buffer)
<<<<<<< HEAD
=======
      cleanup()
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
      done(null, string)
    }
  }

<<<<<<< HEAD
  function cleanup () {
    buffer = null
=======
  function cleanup() {
    received = buffer = null
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538

    stream.removeListener('aborted', onAborted)
    stream.removeListener('data', onData)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onEnd)
    stream.removeListener('close', cleanup)
  }
}
<<<<<<< HEAD
=======

/**
 * Unpipe everything from a stream.
 *
 * @param {Object} stream
 * @private
 */

/* istanbul ignore next: implementation differs between versions */
function unpipe(stream) {
  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return
  }

  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
