<<<<<<< HEAD
declare function pathToRegexp (path: pathToRegexp.Path, keys?: pathToRegexp.Key[], options?: pathToRegexp.RegExpOptions & pathToRegexp.ParseOptions): RegExp;

declare namespace pathToRegexp {
  export interface RegExpOptions {
    /**
     * When `true` the regexp will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
    /**
     * When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)
     */
    strict?: boolean;
    /**
     * When `true` the regexp will match to the end of the string. (default: `true`)
     */
    end?: boolean;
    /**
     * When `true` the regexp will match from the beginning of the string. (default: `true`)
     */
    start?: boolean;
    /**
     * Sets the final character for non-ending optimistic matches. (default: `/`)
     */
    delimiter?: string;
    /**
     * List of characters that can also be "end" characters.
     */
    endsWith?: string | string[];
=======
declare function pathToRegexp (path: pathToRegexp.Path, options?: pathToRegexp.RegExpOptions & pathToRegexp.ParseOptions): pathToRegexp.PathRegExp;
declare function pathToRegexp (path: pathToRegexp.Path, keys?: pathToRegexp.Key[], options?: pathToRegexp.RegExpOptions & pathToRegexp.ParseOptions): pathToRegexp.PathRegExp;

declare namespace pathToRegexp {
  export interface PathRegExp extends RegExp {
    // An array to be populated with the keys found in the path.
    keys: Key[];
  }

  export interface RegExpOptions {
    /**
     * When `true` the route will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
    /**
     * When `false` the trailing slash is optional. (default: `false`)
     */
    strict?: boolean;
    /**
     * When `false` the path will match at the beginning. (default: `true`)
     */
    end?: boolean;
    /**
     * Sets the final character for non-ending optimistic matches. (default: `/`)
     */
    delimiter?: string;
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }

  export interface ParseOptions {
    /**
     * Set the default delimiter for repeat parameters. (default: `'/'`)
     */
    delimiter?: string;
<<<<<<< HEAD
    /**
     * List of valid delimiter characters. (default: `'./'`)
     */
    delimiters?: string | string[];
=======
  }

  export interface TokensToFunctionOptions {
    /**
     * When `true` the regexp will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }

  /**
   * Parse an Express-style path into an array of tokens.
   */
  export function parse (path: string, options?: ParseOptions): Token[];

  /**
   * Transforming an Express-style path into a valid path.
   */
<<<<<<< HEAD
  export function compile (path: string, options?: ParseOptions): PathFunction;
=======
  export function compile (path: string, options?: ParseOptions & TokensToFunctionOptions): PathFunction;
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538

  /**
   * Transform an array of tokens into a path generator function.
   */
<<<<<<< HEAD
  export function tokensToFunction (tokens: Token[]): PathFunction;
=======
  export function tokensToFunction (tokens: Token[], options?: TokensToFunctionOptions): PathFunction;
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538

  /**
   * Transform an array of tokens into a matching regular expression.
   */
<<<<<<< HEAD
  export function tokensToRegExp (tokens: Token[], keys?: Key[], options?: RegExpOptions): RegExp;
=======
  export function tokensToRegExp (tokens: Token[], options?: RegExpOptions): PathRegExp;
  export function tokensToRegExp (tokens: Token[], keys?: Key[], options?: RegExpOptions): PathRegExp;
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538

  export interface Key {
    name: string | number;
    prefix: string;
    delimiter: string;
    optional: boolean;
    repeat: boolean;
    pattern: string;
    partial: boolean;
<<<<<<< HEAD
  }

  interface PathFunctionOptions {
    /**
     * Function for encoding input strings for output.
     */
    encode?: (value: string, token: Key) => string;
=======
    asterisk: boolean;
  }

  interface PathFunctionOptions {
    pretty?: boolean;
>>>>>>> 34f03bf259ef6d5f22c22e47eca085eaa7ac4538
  }

  export type Token = string | Key;
  export type Path = string | RegExp | Array<string | RegExp>;
  export type PathFunction = (data?: Object, options?: PathFunctionOptions) => string;
}

export = pathToRegexp;
